> - 필수적인 연산, 변환, 멤버 초기화
> - 복사와 이동: 컨테이너 복사, 컨테이너 이동
> - 자원 관리
> - 관례적인 연산: 비교, 컨테이너 연산, 입력과 출력, 사용자 정의 리터럴, swap(), hash<>


초기화, 대입, 복사, 이동 등의 연산은 기초적인 연산이므로, 언어 규칙이 해당 연산들에 대한 가정을 쉽게 할 수 없고 \==, \<< 등의 연산에는 관례적인 의미가 있어서 그 의미를 임의로 무시할 수 없음


필수적인 연산
- 객체를 생성하는 일은 대부분의 설계에서 핵심적인 역할을 함; 초기화를 위한 언어 기능이 매우 광범위하고 유연함
- 특정 타입의 생성자, 소멸자, 복사, 이동 연산은 논리적으로 구분되지 않아 잘 구분해 정의하지 않으면 논리적 문제나 성능 문제를 겪게 됨

```c
class X {
public:
	X(Sometype);            // 일반적인 생성자
	X();                    // 기본 생성자
	X(const X&);            // 복사 생성자
	X(X&&)                  // 이동 생성자
	X& operator=(const X&)  // 복사 대입: 대상을 정리하고 복사
	X& operator=(X&&);      // 이동 대입: 대상을 정리하고 이동
	~X();                   // 소멸자: 정리 작업
}
```

객체가 복사되거나 이동되는 경우는 5가지가 존재
- 대입 연산의 원본으로서
- 객체 초깃값으로서
- 함수 인자로서
- 함수 반환 값으로서
- 예외로서

객체 대입 시에는 복사나 이동 대입 연산자를 사용. 그렇지 않은 경우 이론적으로는 복사나 이동 생성자를 사용

그러나 대상 객체 내부를 직접 초기화하는 객체를 만드는 방법으로 복사나 이동 생성자의 호출을 생략해 최적화할 수도 있음
```c
X make(Sometype);
X x = make(value);
```
컴파일러는 make()에서 생성한 X 타입의 객체를 x에서 직접 초기화하므로 복사를 생략할 수 있음

생성자로 명명된 객체나 힙의 객체를 초기화하는 일에 더해 임시 객체를 초기화하거나 명시적인 타입 변환을 구현할 때도 생성자를 이용

일반적인 생성자를 제외한 이러한 특수한 멤버 함수들은 컴파일러가 필요할 때 만들어냄. 기본 구현을 명시적으로 만들고 싶으면 아래 참고
```c
class Y {
public:
	Y(Sometype);
	Y(const Y&) = default; // 기본 복사 생성자 필요
	Y(Y&&) = default; // 기본 이동 생성자 필요
}
```
> 일부 함수들을 default로 명시하면 나머지 기본 함수들은 생성되지 않음

클래스가 포인터 멤버를 포함한다면 복사와 이동 연산자를 명시적으로 정의하는 것이 좋음. delete 해야할 무언가를 포인터가 가리킨다면 기본적인 멤버별 복사는 적합하지 않기 때문
반대로 delete하면 안 되는 것을 포인터가 가리키는 경우에도 코드를 읽는 사람은 그 사실을 알아야함

> 일반적으로는 필수적인 함수를 모두 정의하거나, 모두 기본 함수를 사용하게 아무것도 명시적으로 정의하지 않는 것이 좋음
```c
struct Z {
	Vector v;
	string s
};

Z z1;      // z1.v와 z1.s를 기본 값으로 초기화
Z z2 = z1; // z1.v와 z1.s를 기본 복사
```
여기서 컴파일러는 멤버별 기본 생성자와 복사, 이동, 소멸자를 필요에 따라 원래의 의미에 맞게 조합

=default를 보완하는 용도로 =delete를 이용하면 해당 연산이 생성되지 않음 -> 제거한 후 함수 사용 시 컴파일 시간에 에러 발생
(필수적인 멤버 함수가 아닌 함수의 사용을 막기 위해 =delete 사용할 수 있음)

```c
class Shape {
public:
	Shape(const Shape&) =delete; // 복사 연산 없음
	Shape& operator=(const Shape&) =delete
}

void copy(Shape& s1, Shape& s2) {
	s1 = s2; // 에러: Shape의 복사 연산이 제거됨
}
```

---

변환

인자가 하나뿐인 생성자는 그 인자 타입으로부터의 변환 연산을 정의
Ex. complex는 double을 이용한 생성자를 제공
```c
complex z1 = 3.14; // z1은 {3.14, 0.0}
complex z2 = z1*2; // z2는 z1*{2.0, 0} == {6.28, 0.0} 
```

항상 이상적인 것은 아님
```c
Vector v1 = 7; // OK: v1은 7개 요소를 포함
```
이런 상황처럼 의도하지 않은 상황이 발생할 수 있음

이를 막기 위해 명시적인 변환만 허용한다는 사실을 명시할 수 있음
```c
class Vector {
public:
	explicit Vector(int s); // int에서 Vector로 암묵적인 변환 불가
}

Vector v1(7);  // OK
Vector v2 = 7; // 에러
```

특별한 이유가 없는 한 인자 하나를 받는 생성자에는 explicit을 사용

---

멤버 초깃값

클래스에 데이터 멤버를 정의할 때 기본 멤버 초깃값(default member initilizer)을 지정할 수 있음
```c
class complex {
	double re = 0;
	double im = 0;
public:
	complex(double r, double i) :re{r}, im{i} {} // 두 스칼라 {r, i}로부터 복소수 생성
	complex(double r) :re{r} {} // 스칼라 하나 {r, 0}로 부터 복소수 생성
	complex() {} // 기본 복소수: {0, 0}
}
```

> 생성자가 값을 제공하지 않으면 기본 값을 사용

---

복사와 이동

기본적으로 사용자 정의 타입과 내장 타입을 비롯한 모든 객체는 복사될 수 있음
복사의 기본적 의미는 멤버별 복사

```c
void test(complex z1) {
	complex z2 {z1}; // 복사 초기화
	complex z3;
	z3 = z2; // 복사 대입
}
```

대입과 초기화에서 두 멤버를 모두 복사하므로 z1, z2, z3는 모두 같은 값

> 클래스를 설계할 때는 객체의 복사 방식도 반드시 고려해야함
> 간단한 구체 타입이라면 단순히 멤버별 복사가 적합한 경우도 있지만 Vector처럼 정교한 구체 클래스에서는 멤버별 복사가 적합하지 않음
> 
> 특히 대부분의 추상 타입에서도 마찬가지


---

컨테이너 복사

클래스가 포인터로 접근되는 객체에 대한 책임을 지는 경우에 기본적인 멤버별 복사는 대부분 옳지 않음; 자원 핸들의 불변 조건을 위배할 수 있음
-> 기본 복사 연산으로 복사시 두 벡터가 같은 요소를 가리킴
```c
void bad_copy(Vector v1) {
	Vector v2 = v1; // v1의 메모리 표현을 v2로 복사
	v1[0] = 2; // v2[0]도 2
	v2[1] = 3; // v1[1]도 3
}
```

> Vector가 소멸자를 퐇마하기 때문에 기본(멤버별) 복사의 작동 방식이 옳지 않다는 사실을 알 수 있음


클래스의 객체를 복사하는 일은 복사 생성자와 복사 대입(copy assignment)이라는 두 멤버로 정의 가능
```c
class Vector {
private:
	double* elem;
	int sz;
public:
	Vector(int s);               // 생성자: 불변 조건을 조성하고 자원 획득
	~Vector() { delete[] elem; } // 소멸자: 자원 해제

	Vector(const Vector& a);            // 복사 생성자
	Vector& operator=(const Vector& a); // 복사 대입

	// ...
}
```

Vector의 복사 생성자는 지정된 개수의 요소를 저장할 수 있는 공간을 할당하고, 주어진 요소를 그 공간에 복사해야함
-> 복사 연산 후에도 두 Vector가 각자 요소의 복사본을 갖게 됨
```c
Vector::Vector(const Vector& a) // 복사 생성자
	:elem{new double[a.sz]},    // 공간 할당
	sz{a.sz} {

	for (int i=0; i!=sz; ++i)   // 요소 복사
		elem[i] = a.elem[i];
}
```


복사 생성자와 더불어 복사 대입도 물론 필요

```c
Vector& Vector::operator=(const Vector& a) {
	double* p = new double[a.sz];
	for (int i=0; i!=a.sz; ++i)
		p[i] = a.elem[i];
	
	delete[] elem; // 예전 요소 삭제
	elem = p;
	sz = a.sz;
	return *this;
}
```

> this라는 이름은 멤버 함수에서 미리 정의된 것으로, 멤버 함수가 호출된 객체를 가리킴

---

컨테이너 이동

크기가 큰 객체라면 복사 비용도 클 수 있음
함수에 객체를 전달할 때는 참조를 이용해 복사를 피할 수 있지만 지역 객체의 참조를 결과로 반환할 수는 없음(파괴되니까)
```c
class Vector {
	Vector(const Vector& a);
	Vector& operator=(const Vector& a);
	Vector(Vector&& a);            // 이동 생성자
	Vector& operator=(Vector&& a); // 이동 대입
}
```
이렇게 정의하면 컴파일러가 함수 밖으로 반환 값을 가져올 때 이동 생성자를 선택
r = x + y + z를 실행할 때 Vector를 복사하는 대신 Vector를 이동시킴

정의
```c
Vector::Vector(Vector&& a) {
	:elem{a.elem}, // 인자로부터 요소 가져옴
	sz{a.sz}

	a.elem = nullptr; // 원본 객체는 이제 요소를 포함하지 않음
	a.sz = 0;
}
```


> &&: 'rvalue 참조', 즉 rvalue가 될 수 있는 객체의 참조를 말함
> 대입의 원본이 되는 것, Ex. 함수의 반환값이 될 수 있음
> 따라서 rvalue 참조는 누구도 다시는 대입할 수 없는 것의 참조이므로 안심하고 그 값을 이동시킬 수 있음


> 이동 생성자는 const 인자를 받지 않음; 이동 생성자는 결국 인자의 값을 제거하기 때문

> rvalue 참조를 초깃값으로 사용하거나 대입 연산의 오른쪽에 사용했을 때 이동 연산이 수행

프로그래머는 어떤 값이 다시 사용되지 않을 것을 알지만 컴파일러가 그 사실을 알아차릴 만큼 똑똑하지 않다면 명시할 수 있음
```c
Vector f() {
	Vector x(1000);
	Vector y(2000);
	Vector z(3000);
	z = x; // 복사, 이후에도 f()안에서 x 사용 가능
	y = std:move(x); // 이동(이동 대입)
	// .. 여기서는 x를 사용하지 않는 것이 좋음
	return z; // 이동
}
```

lvalue, rvalue 차이 유념
```c
// 1
Object a(some param);
Ojbect b(some param);
a = b; // b는 lvalue임. copy not move

// 2
const Object b(/*parameters 2*/);
// ...
a = std::move(b); // <-- still copies, b is const
```


표준 라이브러리 함수 move()는 사실 아무것도 이동시키지 않음. 대신에 앞으로 이동시킬 인자의 rvalue 참조를 반환함
따라서 일종의 타입 변환(\_hist.cast_)이라고 할 수 있음

f()에서 return을 수행하기 전의 모습
![[Screenshot 2023-05-19 at 1.56.46 PM.png]]

f()가 반환할 때 return에 의해 z의 요소들이 f() 밖으로 옮겨진 후 z는 소멸
그러나 y의 소멸자는 y의 요소들을 delete\[]

> 객체 초기화 시에는 컴파일러가 C++ 표준에 따라 대부분의 복사를 방지하므로, 생각만큼 이동 생성자가 자주 호출될 일은 없음
> 이러한 복사 생략 덕분에 이동으로 인한 아주 작은 부하조차 없앨 수 있음
> 반면 대입 시에는 암묵적으로 복사나 이동을 막기가 어렵기 때문에 성능적인 관점에서 이동 대입이 중요한 역할


--- 

자원 관리

생성자, 복사, 이동, 소멸자를 정의함으로써 특정 객체에 포함된 자원의 생애 주기를 완벽히 제어할 수 있음

이동 생성자는 한 스코프에서 다른 스코프로 객체를 간단하고 낮은 비용으로 이동시킬 수 있음

표준 라이브러리 thread와 100만 개의 double을 포함하는 Vector를 생각해보면, 전자는 복사가 불가능하고 후자는 복사되길 원치 않음
```c
std::vector<thread> my_threads;

Vector init(int n) {
	thread t {heartbeat}; // heartbeat를 동시적으로(각자 다른 스레드) 실행
	my_threads.push_back(std::move(t)); // t를 my_threads로 이동

	Vector vec(n);
	for (int i=0; i!=vec.size(); ++i)
		vec[i] = 777;
	
	return vec; // vec를 init() 밖으로 이동
}

auto v = init(1'000'000); // heartbeat를 시작하고 v 초기화
```
Vector, thread같은 자원 핸들은 많은 경우에 내장 포인터를 사용하는 것보다 나음
unique_ptr을 비롯한 스마트 포인터는 그 자체로 자원 핸들


> 애플리케이션 코드에서 new와 delete가 사라진 것과 유사하게 포인터가 자원 핸들 속으로 사라지게 할 수 있음
> 강력한 자원 안정성을 달성해 자원 누수를 막을 수 있음
> Ex. vector는 메모리, thread는 시스템 스레드, fstream은 파일 핸들을 안전하게 관리


> 많은 경우에 자원 관리는 주로 가비지 컬렉터에 위임
> C++에서도 가비지 컬렉터를 끼워넣을 수 있게 가비지 컬렉션 인터페이스 제공
> 필자: 좀 더 명확하고 일반적이며 지역화될 수 있는 자원 관리 방법이 더 이상 없을 때 가비지 컬렉션을 최후의 방법으로 고려함. 아예 가비지를 만들어내지 않는 것이 이상적이며, 그런 경우라면 가비지 컬렉터 필요 없음

> 가비지 컬렉션은 기본적으로 전역적인 메모리 관리 방식. 시스템이 점점 분산되면서 지역성이 더 중요해짐 Ex. 캐시, 멀티코어, 클러스터

> 메모리 외에도 다양한 자원 존재 Ex. 락, 소켓, 파일 핸들, 스레드 핸들
> 오랫동안 수행되는 시스템이라면 자원 누수도 피해야 하지만 자원을 과하게 유지하는 것도 문제

> 가비지 컬렉션을 고려하기 전에 자원 핸들을 체계적으로 사용해 각 자원의 소유자가 특정 스코프 안에 존재하고, 스코프가 끝날 때 자원을 해제하게 하자
> C++에서는 이를 RAII라고 하며, 예외를 바탕으로 한 에러 처리도 이를 뒷받침
> 이동 연산이나 스마트 포인터를 이용하면 스코프 사이에서 자원을 이동시킬 수 있고, 소유권이 공유된 경우는 공유 포인터로 표현 가능
> 표준 라이브러리는 RAII가 내재돼 있음.
> - 메모리(string, vector, map, unordered_map 등)
> - 파일(ifstream, ofstream 등)
> - 스레드(thread)
> - 락(lock_guard, unique_lock 등)
> - unique_ptr, shared_ptr로 접근하는 일반적인 객체

--- 

관례적인 연산
- 비교, 컨테이너, 입력/출력, 사용자 정의 리터럴, swap, 해시 함수

비교
- 복사와 밀접하게 연관; 복사 이후에는 원본과 같아야함
```c
X a = something;
X b = a;
assert(a==b)
```

\==를 비롯한 이항 연산자의 두 연산 항을 동등하게 취급할 수 있도록 클래스가 속한 네임스페이스에 독립적인 함수로 이항 연산자를 정의하는 것이 좋음
```c
namespace Nx {
	class X {
		// ...
	};
	bool operator==(const X&, const X&);
};
```


---

컨테이너 연산
- 모든 표준 라이브러리 컨테이는 size()를 호출해 요소의 개수를 구할 수 있음
- 표준 알고리즘에서는 인덱스를 이용해 0부터 size()까지 탐색하는 대신 여러 쌍의 반복자로 정의되는 시퀀스라는 개념 사용
```c
for (auto p=c.begin(); p!=c.end(); ++p)
	*p = 0;
```

c.begin()은 c의 첫 요소를 가리키는 반복자
c.end()는 마지막 요소 다음

포인터와 비슷하게 반복자도 다음 요소로 이동하는 ++와 가리키고 있는 요소의 값에 접근하는 \* 제공

> 반복자 모델을 이용하면 뛰어난 일반성과 효율성을 얻을 수 있음

표준 라이브러리 알고리즘에 시퀀스를 전달할 때 반복자 사용함
```c
sort(v.begin(), v.end());
```

요소의 개수를 암묵적으로 사용하는 또 다른 방법은 구간 for 루프
```c
for (auto& x : c)
	x = 0;
```
이 코드는 암묵적으로 c.begin(), c.end() 사용

---

입력과 출력 연산
<<, >>
정수 쌍인 경우와 다르게 iostreams에 대해서는 출력, 입력 연산 의미

---

사용자 정의 리터럴(UDL, 리터럴 연산자)
- 사용자 정의 접미사를 이용한 리터럴
- 접미사 앞에 주어진 인자 타입의 리터럴을 필요한 타입으로 변환

Ex. imaginary를 나타내는 접미사 i
```c
constexpr complex<double> operator""i(long double arg) // 허수
{
	return {0, arg};
}
```

- operator"": 리터럴 연산자 정의
- 리터럴 지시자(Ex. ""다음의 i): 연산자가 의미를 부여할 접미사
- 인자 타입(Ex. long double): 해당 접미사 i가 부동소수점 수 리터럴에 적용됨을 나타냄
- 반환 타입(Ex. complex\<double>): 결과로 생성될 리터럴 타입

사용 예
```c
complex<double> z = 2.718+6.2831i;
```

표준 라이브러리에서 적절한 헤더와 네임스페이스를 사용하면 이렇게 사용 가능
```c
<complex> std::literals::complex_literals i, il, if
```

---

swap()

많은 알고리즘, 특히 sort()에서는 두 객체의 값을 뒤바꾸는 swap() 함수를 사용
이런 알고리즘은 일반적으로 swap()이 굉장히 빠르고 예외를 던지지 않는다고 가정함

표준 라이브러리에서 제공하는 std::swap(a, b)는 세 번의 이동 연산(tmp=a, a=b, b=tmp)으로 정의

> 본인이 설계하는 타입의 복사 비용이 크고, 두 객체의 값을 맞바꿀 필요가 있으면(Ex. 정렬 함수) 이동 연산자나 swap() 혹은 둘 다를 제공하는 것이 좋음

---

hash<>

표준 라이브러리 unordered_map<K, V>는 키 타입이 K, 값 타입이 V인 해시 테이블

타입 X를 키로 사용하려면 hash<\X>를 반드시 정의해야함